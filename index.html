<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MLB Game Day Dashboard</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/lucide@latest"></script>
    <!-- Library for creating Excel files -->
    <script src="https://cdn.jsdelivr.net/npm/xlsx/dist/xlsx.full.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #111827; /* bg-gray-900 */
            color: #f9fafb; /* text-gray-50 */
        }
        .modal-backdrop {
            background-color: rgba(0, 0, 0, 0.7);
        }
        .modal {
            transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out;
        }
        .stat-table th, .stat-table td {
            padding: 0.75rem 0.5rem;
            text-align: center;
        }
        .stat-table th:first-child, .stat-table td:first-child {
            text-align: left;
            padding-left: 1rem;
        }
        .stat-table tbody tr:nth-child(even) {
            background-color: #1f2937; /* bg-gray-800 */
        }
        .loader {
            border-top-color: #3b82f6;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        #download-all-btn:disabled, #refresh-btn:disabled, #probable-pitchers-btn:disabled {
            cursor: not-allowed;
            background-color: #374151; /* bg-gray-700 */
            opacity: 0.7;
        }
        /* Style for the calendar picker icon */
        input[type="date"]::-webkit-calendar-picker-indicator {
            cursor: pointer;
            filter: invert(1);
        }
    </style>
</head>
<body class="antialiased">

    <div id="app-container" class="container mx-auto p-4 md:p-8">
        <header class="text-center mb-8">
            <h1 class="text-4xl font-bold text-white tracking-tight">MLB Game Day</h1>
            <p class="text-lg text-gray-400 mt-2">Browse daily MLB schedules and box scores.</p>
        </header>

        <div class="max-w-4xl mx-auto mb-8 flex flex-col sm:flex-row gap-2 items-center justify-center">
            <!-- Refresh Button -->
            <div class="w-full sm:w-auto sm:pt-7">
                 <button id="refresh-btn" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-semibold px-4 py-2.5 rounded-md flex items-center justify-center text-sm" title="Refresh data for selected date">
                    <i data-lucide="refresh-cw" class="w-4 h-4"></i>
                </button>
            </div>
            <!-- Date Picker -->
            <div class="w-full sm:w-auto flex-grow">
                <label for="game-date-picker" class="block text-sm font-medium text-gray-300 mb-2 text-center sm:text-left">Select Date:</label>
                <input type="date" id="game-date-picker" class="w-full bg-gray-700 border border-gray-600 rounded-md px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500 text-white">
            </div>
            <!-- Action Buttons -->
            <div class="w-full sm:w-auto sm:pt-7 flex flex-col sm:flex-row gap-2">
                 <button id="download-all-btn" class="w-full bg-green-600 hover:bg-green-700 text-white font-semibold px-4 py-2.5 rounded-md flex items-center justify-center text-sm">
                    <span id="download-btn-text">
                        <i data-lucide="download" class="inline-block w-4 h-4 mr-2"></i>
                        Download Boxscores
                    </span>
                    <span id="download-btn-loader" class="hidden">
                        <div class="loader ease-linear rounded-full border-2 border-t-2 border-gray-200 h-5 w-5 mr-2 inline-block"></div>
                        Fetching...
                    </span>
                </button>
                <button id="probable-pitchers-btn" class="w-full bg-purple-600 hover:bg-purple-700 text-white font-semibold px-4 py-2.5 rounded-md flex items-center justify-center text-sm">
                    <i data-lucide="users" class="inline-block w-4 h-4 mr-2"></i>
                    Probable Pitchers
                </button>
            </div>
        </div>

        <main id="games-grid" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
            <!-- Game cards will be injected here -->
        </main>
        
        <div id="loader" class="text-center py-12 hidden">
            <div class="loader ease-linear rounded-full border-4 border-t-4 border-gray-200 h-12 w-12 mx-auto"></div>
            <p class="mt-4 text-gray-400">Fetching game data...</p>
        </div>
        
        <div id="no-games-message" class="text-center py-12 hidden">
             <i data-lucide="calendar-x" class="mx-auto h-16 w-16 text-white"></i>
            <p class="mt-4 text-xl text-gray-400">No games scheduled for this date.</p>
        </div>

    </div>

    <!-- Main Modal -->
    <div id="main-modal" class="fixed inset-0 z-50 flex items-center justify-center p-4 modal-backdrop hidden">
        <div id="modal-content" class="bg-gray-900 rounded-lg shadow-2xl w-full max-w-6xl max-h-[95vh] flex flex-col modal opacity-0 transform scale-95">
            <div class="p-4 border-b border-gray-700 flex justify-between items-center flex-shrink-0">
                <h3 class="text-xl md:text-2xl font-semibold" id="modal-title"></h3>
                <button id="close-modal-btn" class="text-gray-400 hover:text-white">
                    <i data-lucide="x" class="w-8 h-8"></i>
                </button>
            </div>
            <div id="modal-body" class="p-2 md:p-4 lg:p-6 overflow-y-auto">
                <!-- Modal content will be injected here -->
            </div>
             <div id="modal-loader" class="text-center py-12 hidden">
                <div class="loader ease-linear rounded-full border-4 border-t-4 border-gray-200 h-12 w-12 mx-auto"></div>
                <p class="mt-4 text-gray-400">Fetching data...</p>
            </div>
        </div>
    </div>


    <script type="module">
        // --- DOM Elements ---
        const gameDatePicker = document.getElementById('game-date-picker');
        const gamesGrid = document.getElementById('games-grid');
        const loader = document.getElementById('loader');
        const noGamesMessage = document.getElementById('no-games-message');
        const downloadAllBtn = document.getElementById('download-all-btn');
        const downloadBtnText = document.getElementById('download-btn-text');
        const downloadBtnLoader = document.getElementById('download-btn-loader');
        const refreshBtn = document.getElementById('refresh-btn');
        const probablePitchersBtn = document.getElementById('probable-pitchers-btn');
        
        const mainModal = document.getElementById('main-modal');
        const modalContent = document.getElementById('modal-content');
        const closeModalBtn = document.getElementById('close-modal-btn');
        const modalTitle = document.getElementById('modal-title');
        const modalBody = document.getElementById('modal-body');
        const modalLoader = document.getElementById('modal-loader');

        // --- API Configuration ---
        const API_BASE_URL = 'https://statsapi.mlb.com/api/v1';

        // --- App State ---
        let currentGames = [];

        // --- Functions ---
        
        /**
         * Fetches and displays games for a given date
         * @param {string} dateString The date in 'YYYY-MM-DD' format
         */
        async function fetchAndDisplayGames(dateString) {
            gamesGrid.innerHTML = '';
            currentGames = [];
            noGamesMessage.classList.add('hidden');
            loader.classList.remove('hidden');
            [downloadAllBtn, refreshBtn, probablePitchersBtn].forEach(btn => btn.disabled = true);

            try {
                const response = await fetch(`${API_BASE_URL}/schedule?sportId=1&date=${dateString}&hydrate=decisions,probablePitcher(stats(type=season))`);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const data = await response.json();

                if (data.totalGames === 0) {
                    noGamesMessage.classList.remove('hidden');
                } else {
                    currentGames = data.dates[0].games;
                    renderGames(currentGames);
                    downloadAllBtn.disabled = false;
                }
            } catch (error) {
                console.error("Error fetching schedule:", error);
                gamesGrid.innerHTML = `<p class="text-red-400 text-center col-span-full">Could not fetch game data. Please try again later.</p>`;
            } finally {
                loader.classList.add('hidden');
                [refreshBtn, probablePitchersBtn].forEach(btn => btn.disabled = false);
            }
        }

        /**
         * Renders game cards to the grid
         * @param {Array} games Array of game objects from the API
         */
        function renderGames(games) {
            gamesGrid.innerHTML = '';

            const sortedGames = [...games].sort((a, b) => {
                const aIsPostponed = a.status.detailedState === 'Postponed';
                const bIsPostponed = b.status.detailedState === 'Postponed';

                if (aIsPostponed && !bIsPostponed) return -1;
                if (!aIsPostponed && bIsPostponed) return 1;
                
                return new Date(a.gameDate) - new Date(b.gameDate);
            });

            sortedGames.forEach(game => {
                const awayTeam = game.teams.away;
                const homeTeam = game.teams.home;
                const status = game.status.detailedState;
                const isFinal = status === 'Final' || status.includes('Completed');
                const isPostponed = status === 'Postponed';
                const isDoubleHeader = game.doubleHeader === 'Y' || game.doubleHeader === 'S';
                const isResumed = !!game.resumedFrom;

                const gameCard = document.createElement('div');
                let cardClasses = 'bg-gray-800 rounded-lg p-4 flex flex-col transition-all duration-200';
                
                if (isPostponed) {
                    cardClasses += ' bg-red-900/40 border-2 border-red-600';
                } else {
                    cardClasses += ' cursor-pointer hover:ring-2 ring-blue-500';
                    gameCard.dataset.gamePk = game.gamePk;
                    if (isDoubleHeader || isResumed) {
                         cardClasses += ' border-2 border-yellow-500';
                    }
                }
                gameCard.className = cardClasses;

                let decisionHtml = '';
                if (isPostponed) {
                    const rescheduledDate = game.rescheduledGameDate ? new Date(game.rescheduledGameDate).toLocaleDateString() : 'TBD';
                    decisionHtml = `
                    <div class="mt-4 pt-2 text-xs text-red-300">
                        <p class="font-semibold">Rescheduled to: ${rescheduledDate}</p>
                        ${game.description ? `<p>${game.description}</p>` : ''}
                    </div>
                    `;
                } else if (isFinal) {
                    const winnerName = normalizeString(game.decisions?.winner?.fullName || 'N/A');
                    const loserName = normalizeString(game.decisions?.loser?.fullName || 'N/A');
                    const saveName = game.decisions?.save ? normalizeString(game.decisions.save.fullName) : '';
                    decisionHtml = `
                    <div class="border-t border-gray-700 mt-4 pt-2 text-xs text-gray-400">
                        <p>W: ${winnerName}</p>
                        <p>L: ${loserName}</p>
                        ${saveName ? `<p>S: ${saveName}</p>` : ''}
                    </div>
                    `;
                } else {
                    const formatPitcherInfo = (pitcher) => {
                        if (!pitcher) return 'TBD';
                        const name = normalizeString(pitcher.fullName);
                        let statsString = '';
                        const seasonStats = pitcher.stats?.find(s => s.type?.displayName === 'season' && s.group?.displayName === 'pitching');
                        if (seasonStats?.stat) {
                            const { wins = 0, losses = 0, era = '0.00' } = seasonStats.stat;
                            statsString = ` (${wins}-${losses}, ${era})`;
                        }
                        return `${name}${statsString}`;
                    };

                    const awayPitcherInfo = formatPitcherInfo(game.teams.away.probablePitcher);
                    const homePitcherInfo = formatPitcherInfo(game.teams.home.probablePitcher);

                    decisionHtml = `
                    <div class="border-t border-gray-700 mt-4 pt-2 text-xs text-gray-400">
                        <p>A: ${awayPitcherInfo}</p>
                        <p>H: ${homePitcherInfo}</p>
                    </div>
                    `;
                }
                
                let gameTypeIndicator = '';
                if (isDoubleHeader) {
                    gameTypeIndicator = `<span class="text-xs font-bold text-yellow-400"> (DH Game ${game.gameNumber})</span>`;
                } else if (isResumed) {
                     gameTypeIndicator = `<span class="text-xs font-bold text-yellow-400"> (Resumed)</span>`;
                }

                gameCard.innerHTML = `
                    <div class="flex-grow">
                        <p class="text-sm text-gray-400 mb-2">${status}${gameTypeIndicator} ${isPostponed ? '' : `- ${new Date(game.gameDate).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}`}</p>
                        <div class="flex items-center justify-between mb-2">
                            <span class="font-semibold text-lg">${awayTeam.team.name}</span>
                            <span class="font-bold text-2xl">${isPostponed ? '-' : (awayTeam.score ?? 0)}</span>
                        </div>
                        <div class="flex items-center justify-between">
                            <span class="font-semibold text-lg">${homeTeam.team.name}</span>
                            <span class="font-bold text-2xl">${isPostponed ? '-' : (homeTeam.score ?? 0)}</span>
                        </div>
                    </div>
                    ${decisionHtml}
                `;
                gamesGrid.appendChild(gameCard);

                if (!isFinal && !isPostponed) {
                    updatePitcherStatsOnCard(game);
                }
            });
            lucide.createIcons();
        }

        async function getPitcherSeasonStats(pitcherId) {
            if (!pitcherId) return null;
            try {
                const response = await fetch(`${API_BASE_URL}/people/${pitcherId}?hydrate=stats(type=season)`);
                if (!response.ok) return null;
                const data = await response.json();
                const pitcher = data.people[0];
                const seasonStats = pitcher.stats?.find(s => s.type?.displayName === 'season' && s.group?.displayName === 'pitching');
                return seasonStats?.stat || null;
            } catch (error) {
                console.error(`Error fetching stats for pitcher ${pitcherId}:`, error);
                return null;
            }
        }

        async function updatePitcherStatsOnCard(game) {
            const awayPitcherId = game.teams.away.probablePitcher?.id;
            const homePitcherId = game.teams.home.probablePitcher?.id;

            const [awayStats, homeStats] = await Promise.all([
                getPitcherSeasonStats(awayPitcherId),
                getPitcherSeasonStats(homePitcherId)
            ]);

            const awayPitcherElem = document.getElementById(`away-pitcher-${game.gamePk}`);
            const homePitcherElem = document.getElementById(`home-pitcher-${game.gamePk}`);

            if (awayPitcherElem && game.teams.away.probablePitcher) {
                const name = normalizeString(game.teams.away.probablePitcher.fullName);
                const statsString = awayStats ? ` (${awayStats.wins || 0}-${awayStats.losses || 0}, ${awayStats.era || '0.00'})` : '';
                awayPitcherElem.textContent = `A: ${name}${statsString}`;
            }
            
            if (homePitcherElem && game.teams.home.probablePitcher) {
                const name = normalizeString(game.teams.home.probablePitcher.fullName);
                const statsString = homeStats ? ` (${homeStats.wins || 0}-${homeStats.losses || 0}, ${homeStats.era || '0.00'})` : '';
                homePitcherElem.textContent = `H: ${name}${statsString}`;
            }
        }

        /**
         * Fetches and displays the box score for a specific game
         * @param {string} gamePk The unique ID for the game
         */
        async function fetchAndDisplayBoxscore(gamePk) {
            openModal();
            modalTitle.textContent = 'Box Score';
            modalBody.innerHTML = '';
            modalLoader.classList.remove('hidden');

            try {
                const game = currentGames.find(g => g.gamePk == gamePk);
                const response = await fetch(`${API_BASE_URL}/game/${gamePk}/boxscore`);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const data = await response.json();
                renderBoxscore(data, game.decisions);
            } catch (error) {
                console.error("Error fetching boxscore:", error);
                modalBody.innerHTML = `<p class="text-red-400 text-center">Could not fetch box score data.</p>`;
            } finally {
                modalLoader.classList.add('hidden');
            }
        }

        /**
         * Renders the detailed box score inside the modal
         * @param {Object} data The boxscore data from the API
         * @param {Object} decisions The decisions object for the game
         */
        function renderBoxscore(data, decisions) {
            const { away, home } = data.teams;
            modalTitle.textContent = `${away.team.name} @ ${home.team.name}`;
            
            const createPlayerTable = (teamData, type) => {
                const players = teamData.players;
                const statsType = type === 'batting' ? 'batting' : 'pitching';
                const headers = type === 'batting' 
                    ? ['Player', 'AB', 'R', 'H', 'RBI', 'BB', 'SO', 'LOB', 'AVG', 'OPS'] 
                    : ['Player', 'IP', 'H', 'R', 'ER', 'BB', 'SO', 'HR', 'ERA', 'Result'];

                let tableRows = '';
                
                if (type === 'batting') {
                    const battingOrder = teamData.battingOrder.map(id => `ID${id}`);
                    const allBattersInGame = new Set(teamData.batters.map(id => `ID${id}`));
                    const subs = [...allBattersInGame].filter(id => !battingOrder.includes(id));
                    const orderedPlayerIDs = [...battingOrder, ...subs];
                    const pitcherIds = new Set(teamData.pitchers.map(id => `ID${id}`));

                    orderedPlayerIDs.forEach((playerID) => {
                        const player = players[playerID];
                        if (player && player.stats.batting && !pitcherIds.has(playerID)) {
                            const stats = player.stats.batting;
                            let namePrefix = '';
                            const battingOrderIndex = battingOrder.indexOf(playerID);
                            if (battingOrderIndex !== -1) {
                                namePrefix = `${battingOrderIndex + 1}. `;
                            } else {
                                namePrefix = 'PH ';
                            }
                            tableRows += `
                                <tr>
                                    <td class="whitespace-nowrap text-left">${namePrefix}${player.person.fullName} <span class="text-gray-400">${player.position.abbreviation}</span></td>
                                    <td>${stats.atBats ?? 0}</td><td>${stats.runs ?? 0}</td><td>${stats.hits ?? 0}</td>
                                    <td>${stats.rbi ?? 0}</td><td>${stats.baseOnBalls ?? 0}</td><td>${stats.strikeOuts ?? 0}</td>
                                    <td>${stats.leftOnBase ?? 0}</td><td>${player.seasonStats.batting.avg ?? '.---'}</td><td>${player.seasonStats.batting.ops ?? '.---'}</td>
                                </tr>`;
                        }
                    });
                } else { // Pitching
                    teamData.pitchers.forEach((playerID, index) => {
                        const player = players[`ID${playerID}`];
                        if (player && player.stats.pitching) {
                            const stats = player.stats.pitching;
                            let resultCell = '';
                            if (decisions?.winner?.id === player.person.id) resultCell = 'W';
                            else if (decisions?.loser?.id === player.person.id) resultCell = 'L';
                            else if (decisions?.save?.id === player.person.id) resultCell = 'S';
                            else if (stats.holds > 0) resultCell = 'H';
                            
                            const position = index === 0 ? 'SP' : 'RP';

                            tableRows += `
                                <tr>
                                    <td class="whitespace-nowrap text-left">${player.person.fullName} <span class="text-gray-400">${position}</span></td>
                                    <td>${stats.inningsPitched ?? '0.0'}</td><td>${stats.hits ?? 0}</td><td>${stats.runs ?? 0}</td>
                                    <td>${stats.earnedRuns ?? 0}</td><td>${stats.baseOnBalls ?? 0}</td><td>${stats.strikeOuts ?? 0}</td>
                                    <td>${stats.homeRuns ?? 0}</td><td>${player.seasonStats.pitching.era ?? '-.--'}</td><td>${resultCell}</td>
                                </tr>`;
                        }
                    });
                }


                return `
                    <div class="mb-8">
                        <h4 class="text-xl font-semibold mb-2">${teamData.team.name} ${type.charAt(0).toUpperCase() + type.slice(1)}</h4>
                        <div class="overflow-x-auto rounded-lg border border-gray-700">
                            <table class="min-w-full divide-y divide-gray-700 stat-table">
                                <thead class="bg-gray-800"><tr>${headers.map(h => `<th>${h}</th>`).join('')}</tr></thead>
                                <tbody class="divide-y divide-gray-700">${tableRows}</tbody>
                            </table>
                        </div>
                    </div>
                `;
            };

            modalBody.innerHTML = `
                ${createPlayerTable(away, 'batting')}
                ${createPlayerTable(home, 'batting')}
                ${createPlayerTable(away, 'pitching')}
                ${createPlayerTable(home, 'pitching')}
            `;
        }

        async function showProbablePitchers() {
            openModal();
            const selectedDate = gameDatePicker.value;
            modalTitle.textContent = `Probable Pitchers for ${selectedDate}`;
            modalBody.innerHTML = '';
            modalLoader.classList.remove('hidden');

            try {
                const response = await fetch(`${API_BASE_URL}/schedule?sportId=1&date=${selectedDate}&hydrate=probablePitcher`);
                if (!response.ok) throw new Error('Failed to fetch schedule');
                const data = await response.json();

                if (data.totalGames === 0) {
                    modalBody.innerHTML = `<p class="text-center text-gray-400">No games scheduled for ${selectedDate}.</p>`;
                    return;
                }

                const games = data.dates[0].games;
                const headers = ['Date', 'Time (KST)', 'Home Team', 'Away Team', 'Home Pitcher', 'Away Pitcher'];
                let tableRows = '';

                games.forEach(game => {
                    const awayTeam = game.teams.away.team.name;
                    const homeTeam = game.teams.home.team.name;
                    const awayPitcher = normalizeString(game.teams.away.probablePitcher?.fullName || 'TBD');
                    const homePitcher = normalizeString(game.teams.home.probablePitcher?.fullName || 'TBD');
                    const gameTimeKST = new Date(game.gameDate).toLocaleTimeString('en-US', {
                        hour: '2-digit',
                        minute: '2-digit',
                        hour12: false,
                        timeZone: 'Asia/Seoul'
                    });

                    tableRows += `
                        <tr>
                            <td>${selectedDate}</td>
                            <td>${gameTimeKST}</td>
                            <td class="whitespace-nowrap text-left">${homeTeam}</td>
                            <td class="whitespace-nowrap text-left">${awayTeam}</td>
                            <td>${homePitcher}</td>
                            <td>${awayPitcher}</td>
                        </tr>
                    `;
                });

                modalBody.innerHTML = `
                    <div class="overflow-x-auto rounded-lg border border-gray-700">
                        <table class="min-w-full divide-y divide-gray-700 stat-table">
                            <thead class="bg-gray-800"><tr>${headers.map(h => `<th>${h}</th>`).join('')}</tr></thead>
                            <tbody class="divide-y divide-gray-700">${tableRows}</tbody>
                        </table>
                    </div>
                `;

            } catch (error) {
                console.error("Error fetching probable pitchers:", error);
                modalBody.innerHTML = `<p class="text-red-400 text-center">Could not fetch probable pitcher data.</p>`;
            } finally {
                modalLoader.classList.add('hidden');
            }
        }
        
        /**
         * Fetches all data for a day and triggers an XLSX download
         */
        async function downloadAllGamesXLSX() {
            if (currentGames.length === 0) {
                alert("No games to download for the selected date.");
                return;
            }

            downloadAllBtn.disabled = true;
            refreshBtn.disabled = true;
            downloadBtnText.classList.add('hidden');
            downloadBtnLoader.classList.remove('hidden');

            try {
                const gameDataPromises = currentGames.map(game => {
                    const boxscorePromise = fetch(`${API_BASE_URL}/game/${game.gamePk}/boxscore`).then(res => res.json());
                    const linescorePromise = fetch(`${API_BASE_URL}/game/${game.gamePk}/linescore`).then(res => res.json());
                    // Pass along the decisions from the initial fetch
                    return Promise.all([boxscorePromise, linescorePromise, Promise.resolve(game.decisions)]);
                });

                const allGamesData = await Promise.all(gameDataPromises);

                const wb = XLSX.utils.book_new();
                const allSheetData = [];
                
                const maxInnings = Math.max(...allGamesData.map(([, ls]) => ls.innings.length));

                allGamesData.forEach(([boxscore, linescore, decisions]) => {
                    allSheetData.push(...convertGameDataToArray(boxscore, linescore, decisions, maxInnings));
                    allSheetData.push([]); // Blank row between games
                    allSheetData.push([]); // Blank row between games
                });
                
                const ws = XLSX.utils.aoa_to_sheet(allSheetData);
                XLSX.utils.book_append_sheet(wb, ws, "Game Data");

                const date = gameDatePicker.value;
                const filename = `mlb_games_${date}.xlsx`;
                XLSX.writeFile(wb, filename);

            } catch (error) {
                console.error("Error downloading all game data:", error);
                alert("Failed to download all game data. Please check the console for errors.");
            } finally {
                downloadAllBtn.disabled = false;
                refreshBtn.disabled = false;
                downloadBtnText.classList.remove('hidden');
                downloadBtnLoader.classList.add('hidden');
            }
        }

        /**
         * Removes accents and special characters from a string.
         * @param {string} str The string to normalize.
         * @returns {string} The normalized string.
         */
        function normalizeString(str) {
            if (!str) return '';
            return str
                .normalize("NFD") // Decompose combined graphemes into base characters and diacritics
                .replace(/[\u0300-\u036f]/g, "") // Remove diacritics
                .replace(/ñ/g, 'n')
                .replace(/Ñ/g, 'N');
        }

        /**
         * Formats an IP decimal string (e.g., "6.2") into a fractional string (e.g., "6 2/3").
         * @param {string} ipDecimalString - The IP string from the API.
         * @returns {string} The IP string formatted with fractions.
         */
        function formatIp(ipDecimalString) {
            if (!ipDecimalString || ipDecimalString === '0.0') return '0';
            const parts = ipDecimalString.split('.');
            const innings = parts[0];
            const outs = parts[1];

            if (!outs || outs === '0') {
                return innings;
            }

            const fraction = outs === '1' ? '1/3' : '2/3';

            if (innings === '0') {
                return fraction;
            }

            return `${innings} ${fraction}`;
        }

        /**
         * Converts a single game's data into an array of arrays for XLSX.
         * @param {object} boxscore - The boxscore data for a game.
         * @param {object} linescore - The linescore data for a game.
         * @param {object} decisions - The decisions object for the game.
         * @param {number} maxInnings - The maximum number of innings for the day for padding.
         * @returns {Array<Array<string>>} An array of rows for one game.
         */
        function convertGameDataToArray(boxscore, linescore, decisions, maxInnings) {
            const { away, home } = boxscore.teams;
            let data = [];

            data.push([`Game: ${away.team.name} @ ${home.team.name}`]);
            data.push([`Date: ${gameDatePicker.value}`]);
            data.push([]);

            // Linescore
            const inningHeaders = Array.from({ length: maxInnings }, (_, i) => i + 1);
            data.push(['Team', ...inningHeaders, 'R', 'H', 'E']);

            const awayInningScores = linescore.innings.map(i => i.away.runs ?? 0);
            const homeInningScores = linescore.innings.map(i => i.home.runs ?? 0);
            while (awayInningScores.length < maxInnings) awayInningScores.push('');
            while (homeInningScores.length < maxInnings) homeInningScores.push('');

            data.push([away.team.name, ...awayInningScores, linescore.teams.away.runs, linescore.teams.away.hits, linescore.teams.away.errors]);
            data.push([home.team.name, ...homeInningScores, linescore.teams.home.runs, linescore.teams.home.hits, linescore.teams.home.errors]);
            data.push([]);

            const processTeam = (teamData) => {
                const pitcherIds = new Set(teamData.pitchers.map(id => `ID${id}`));
                const battingOrder = teamData.battingOrder.map(id => `ID${id}`);
                const allBattersInGame = new Set(teamData.batters.map(id => `ID${id}`));
                const subs = [...allBattersInGame].filter(id => !battingOrder.includes(id));
                const orderedBatters = [...battingOrder, ...subs];

                // Batting
                data.push([`${teamData.team.name} - Batting`]);
                data.push(['Player', 'Position', 'AB', 'R', 'H', 'RBI', 'BB', 'SO', 'LOB', 'AVG', 'OPS']);
                
                orderedBatters.forEach((id) => {
                    const p = teamData.players[id];
                    if (p && p.stats.batting && !pitcherIds.has(id)) {
                        const s = p.stats.batting;
                        const normalizedName = normalizeString(p.person.fullName);
                        let namePrefix = '';
                        const battingOrderIndex = battingOrder.indexOf(id);
                        if (battingOrderIndex !== -1) {
                            namePrefix = `${battingOrderIndex + 1}. `;
                        } else {
                            namePrefix = 'PH ';
                        }
                        const playerNameCell = `${namePrefix}${normalizedName}`;
                        data.push([playerNameCell, p.position.abbreviation, s.atBats ?? 0, s.runs ?? 0, s.hits ?? 0, s.rbi ?? 0, s.baseOnBalls ?? 0, s.strikeOuts ?? 0, s.leftOnBase ?? 0, p.seasonStats.batting.avg ?? 'N/A', p.seasonStats.batting.ops ?? 'N/A']);
                    }
                });
                const teamBattingStats = teamData.teamStats.batting;
                data.push(['Total', '', teamBattingStats.atBats, teamBattingStats.runs, teamBattingStats.hits, teamBattingStats.rbi, teamBattingStats.baseOnBalls, teamBattingStats.strikeOuts, teamBattingStats.leftOnBase, teamBattingStats.avg, teamBattingStats.ops]);
                data.push([]);

                // Pitching
                data.push([`${teamData.team.name} - Pitching`]);
                const pitchingHeader = ['Player', 'Position', 'IP', 'H', 'R', 'ER', 'BB', 'SO', 'HR', 'ERA', 'Result'];
                const totalHeader = ['', 'Total IP', 'Total H', 'Total R', 'Total ER', 'Total BB', 'Total SO', 'Total HR', 'Total ERA'];
                data.push([...pitchingHeader, ...totalHeader]);
                
                const teamPitchingStats = teamData.teamStats.pitching;
                const totalIpString = formatIp(teamPitchingStats.inningsPitched);
                const totalEra = teamPitchingStats.era;

                teamData.pitchers.forEach((id, index) => {
                    const p = teamData.players[`ID${id}`];
                     if (p && p.stats.pitching) {
                        const s = p.stats.pitching;
                        const normalizedName = normalizeString(p.person.fullName);
                        const ipString = formatIp(s.inningsPitched ?? '0.0');
                        
                        let result = '';
                        if (decisions?.winner?.id === p.person.id) result = 'W';
                        else if (decisions?.loser?.id === p.person.id) result = 'L';
                        else if (decisions?.save?.id === p.person.id) result = 'S';
                        else if (s.holds > 0) result = 'H';
                        
                        const position = index === 0 ? 'SP' : 'RP';
                        
                        const pitcherRow = [normalizedName, position, ipString, s.hits ?? 0, s.runs ?? 0, s.earnedRuns ?? 0, s.baseOnBalls ?? 0, s.strikeOuts ?? 0, s.homeRuns ?? 0, p.seasonStats.pitching.era ?? 'N/A', result];
                        
                        if (index === 0) {
                            pitcherRow.push(
                                '', // Empty cell for spacing
                                totalIpString, 
                                teamPitchingStats.hits, 
                                teamPitchingStats.runs, 
                                teamPitchingStats.earnedRuns, 
                                teamPitchingStats.baseOnBalls, 
                                teamPitchingStats.strikeOuts, 
                                teamPitchingStats.homeRuns, 
                                totalEra
                            );
                        }
                        data.push(pitcherRow);
                    }
                });
                data.push([]);
            };

            processTeam(away);
            processTeam(home);

            return data;
        }

        function openModal() {
            mainModal.classList.remove('hidden');
            setTimeout(() => modalContent.classList.remove('opacity-0', 'scale-95'), 10);
        }

        function closeModal() {
            modalContent.classList.add('opacity-0', 'scale-95');
            setTimeout(() => mainModal.classList.add('hidden'), 300);
        }

        // --- Event Listeners ---
        gameDatePicker.addEventListener('change', () => {
            const selectedDate = gameDatePicker.value;
            localStorage.setItem('mlbDashboardSelectedDate', selectedDate); // Save date to browser storage
            fetchAndDisplayGames(selectedDate);
        });

        refreshBtn.addEventListener('click', () => {
            fetchAndDisplayGames(gameDatePicker.value);
        });

        gamesGrid.addEventListener('click', (e) => {
            const gameCard = e.target.closest('[data-game-pk]');
            if (gameCard) fetchAndDisplayBoxscore(gameCard.dataset.gamePk);
        });

        closeModalBtn.addEventListener('click', closeModal);
        
        downloadAllBtn.addEventListener('click', downloadAllGamesXLSX);
        
        probablePitchersBtn.addEventListener('click', showProbablePitchers);

        mainModal.addEventListener('click', (e) => {
            if (e.target === mainModal) closeModal();
        });

        // --- Initialization ---
        function init() {
            const savedDate = localStorage.getItem('mlbDashboardSelectedDate');
            let initialDate;

            if (savedDate) {
                initialDate = savedDate;
            } else {
                // Default to yesterday's date to ensure there are completed games
                const today = new Date();
                const yesterday = new Date(today);
                yesterday.setDate(yesterday.getDate() - 1);
                const offset = yesterday.getTimezoneOffset();
                const localYesterday = new Date(yesterday.getTime() - (offset * 60 * 1000));
                initialDate = localYesterday.toISOString().split('T')[0];
            }
            
            gameDatePicker.value = initialDate;
            fetchAndDisplayGames(initialDate);
            lucide.createIcons();
        }

        init();

    </script>
</body>
</html>
